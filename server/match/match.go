package match

import (
	"context"
	"crypto/rand"
	"fmt"
	"log"
	"math/big"
	"os"
	"sync"
	"time"

	"server/proto"

	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

var (
	// Logger is the default logger
	Logger = log.New(os.Stdout, "", log.LstdFlags)
)

const (
	// recoveryWindow is the time the match waits if a player is disconnected before gracefully cleaning up
	idleWindow        = 5 * time.Minute
	scavengerInterval = 15 * time.Second
)

// match holds the state of an in progress match while players are being matched for a game
type match struct {
	Game        string             // the game being played (game type)
	Version     string             // the version of the game being played
	Code        string             // player friendly code generated by the server for the player to join the game
	PlayerLimit int                // the number of players required for the game
	Players     map[string]*player // the players of the game
	GameID      string             // the game ID once the match is complete
	location    string             // the location of the game service once the match is complete
	lock        sync.Mutex         // the lock to serialize the match from modification
	lastUpdated time.Time          // the last time the match was updated
	deleted     chan bool          // signal when the player has been deleted
}

// player is a game player
type player struct {
	ID           string                         // player identifier (generated by client)
	Index        int                            // player index
	channelIndex int                            // tracks channel added to be used a channel key
	channels     map[int]chan *proto.MatchEvent // queue of match events for the player
	lock         sync.Mutex                     // the lock to serialize the player from modification
}

// newPlayer creates a new role
func newPlayer(id string, index int) *player {
	return &player{
		ID:       id,
		Index:    index,
		channels: make(map[int]chan *proto.MatchEvent),
	}
}

// Service provides a running service instance. There is only one service
// instance so critical section management is required in the remaining code.
// All completed matches must be removed or there will be a memory leak.
type Service struct {
	gameServerURL string                       // the URL of the game server
	lock          sync.Mutex                   // the lock to serialize modification of the active matches
	matches       map[string]map[string]*match // the active matches [by code] (for all players in all matches)
}

// NewService creates a new MatchService
func NewService(gameServerURL string) (*Service, error) {
	service := &Service{
		lock:          sync.Mutex{},
		matches:       make(map[string]map[string]*match),
		gameServerURL: gameServerURL,
	}
	go service.scavenge()
	return service, nil
}

// Match allows a client to register for a match and listen for match notifications
func (service *Service) Match(request *proto.MatchRequest, stream proto.MatchService_MatchServer) error {
	Logger.Printf("INFO MatchService matching; request:%+v", request)

	m, p, i, err := service.match(request)
	if err != nil {
		Logger.Printf("WARN MatchService could not match; match:%+v", request)
		return err
	}

	// There are three things that could happen in the next code:
	// 1. An event can be dequeued
	// 2. The channel could be closed by the server
	// 3. The channel could be closed by the client
	for {
		select {
		case event, ok := <-p.channels[i]:
			if !ok { // closed by server
				Logger.Printf("ERROR MatchService connection erroneously disconnected by server; game:%v code:%v player:%v", m.Game, m.Code, p.ID)
				return nil
			}
			Logger.Printf("DEBUG MatchService sending game:%v code:%v player:%v event:%+v", m.Game, m.Code, p.ID, event)
			err := stream.Context().Err()
			if err == nil {
				err = stream.Send(event)
			}
			Logger.Printf("DEBUG MatchService sent game:%v code:%v player:%v event:%+v", m.Game, m.Code, p.ID, event)
			if err != nil { // failed to send to client
				Logger.Printf("WARN MatchService event send failed; game:%v code:%v player:%v", m.Game, m.Code, p.ID)
				service.deleteChannel(m, p, i)
				return status.Errorf(codes.DataLoss, "listener_aborted")
			}
		case <-stream.Context().Done(): // closed by client
			Logger.Printf("WARN MatchService connection disconnected by client; game:%v code:%v player:%v", m.Game, m.Code, p.ID)
			service.deleteChannel(m, p, i)
			return nil
		case <-m.deleted: // closed by server
			Logger.Printf("DEBUG MatchService connection disconnected by server; game:%v code:%v player:%v", m.Game, m.Code, p.ID)
			return nil
		}
	}
}

// match is a function to have a player join or start a match. It adds
// the new player and assigns them an index, and notifies the other players.
func (service *Service) match(request *proto.MatchRequest) (*match, *player, int, error) {
	m, err := service.find(request.Game, request.Version, request.Code)
	if err != nil {
		return nil, nil, 0, err
	}

	if request.PlayerId == "" {
		return nil, nil, 0, status.Errorf(codes.InvalidArgument, "invalid_playerId")
	}

	m.lock.Lock()
	defer m.lock.Unlock()

	var p *player
	var ok bool

	if p, ok = m.Players[request.PlayerId]; !ok {
		//create a new player if the match is not full
		if len(m.Players) >= int(request.PlayerLimit) {
			return nil, nil, 0, status.Errorf(codes.ResourceExhausted, "match_full")
		}

		p = newPlayer(request.PlayerId, len(m.Players))
		m.Players[request.PlayerId] = p
	}

	//prevent abuse
	if len(p.channels) == 3 {
		return nil, nil, 0, status.Errorf(codes.ResourceExhausted, "connection_limit_reached")
	}

	//allow multiple connections for a player to avoid timing issues between client and server
	c := make(chan *proto.MatchEvent)
	i := p.channelIndex
	p.channels[i] = c
	p.channelIndex++

	// always update the match with player limit from latest request
	m.PlayerLimit = int(request.PlayerLimit)

	//the match is complete
	if len(m.Players) == m.PlayerLimit && m.GameID == "" {
		m.GameID, err = service.createGame(m)
		if err != nil {
			return nil, nil, 0, err
		}
		m.location = service.gameServerURL

	}
	m.lastUpdated = time.Now().UTC()

	service.notify(m)
	return m, p, i, nil
}

// notify notifies all players of match events
// the anonymous goroutine manages the channel for the grpc stream and closes it once the match completes or the player is deleted
func (service *Service) notify(m *match) {
	for _, p := range m.Players {
		e := &proto.MatchEvent{
			Code:        m.Code,
			PlayerCount: int32(len(m.Players)),
			PlayerIndex: int32(p.Index),
			GameId:      m.GameID,
			Location:    m.location,
		}

		for i := range p.channels {
			go func(p *player, i int) {
				for {
					Logger.Printf("DEBUG MatchService goroutine entered; game:%v code:%v player:%v event:%v connection:%v", m.Game, m.Code, p.ID, e, i)
					select {
					case p.channels[i] <- e:
						Logger.Printf("DEBUG MatchService goroutine exited after send; game:%v code:%v player:%v event:%v connection:%v", m.Game, m.Code, p.ID, e, i)
						return
					case <-m.deleted:
						Logger.Printf("DEBUG MatchService goroutine cleaned up; game:%v code:%v player:%v  event:%v connection:%v", m.Game, m.Code, p.ID, e, i)
						return
					}
				}
			}(p, i)
		}
	}
}

// find is a utility function to get the match from the game and code and create the match if it doesn't exist
func (service *Service) find(game string, version string, code string) (*match, error) {
	if game == "" {
		return nil, status.Errorf(codes.InvalidArgument, "invalid_game")
	}

	var matches map[string]*match
	var ok bool

	service.lock.Lock()
	defer service.lock.Unlock()

	if matches, ok = service.matches[game]; !ok {
		matches = make(map[string]*match)
		service.matches[game] = matches
	}

	if code != "" {
		var m *match
		if m, ok = matches[code]; !ok {
			return nil, status.Errorf(codes.NotFound, "match_not_found")
		}
		if m.Version != version {
			return nil, status.Errorf(codes.InvalidArgument, "invalid_version")
		}
		return m, nil
	}

	// generates a unique match code (that isn't currently active)
	for code = createCode(); isDuplicate(matches, code); code = createCode() {
		// pass
	}

	m := &match{
		Game:        game,
		Version:     version,
		Code:        code,
		Players:     make(map[string]*player),
		lastUpdated: time.Now().UTC(),
		deleted:     make(chan bool),
	}
	service.matches[game][code] = m
	return m, nil
}

// createGame creates a game on the game service and returns the gameId
func (service *Service) createGame(m *match) (string, error) {
	Logger.Printf("INFO MatchService starting game; game:%v code:%v", m.Game, m.Code)

	// call proto
	conn, err := grpc.Dial(service.gameServerURL, grpc.WithInsecure())
	if err != nil {
		return "", err
	}
	defer conn.Close()

	playerIDs := make([]string, 0)
	for playerID := range m.Players {
		playerIDs = append(playerIDs, playerID)
	}
	client := proto.NewGameServiceClient(conn)
	request := &proto.CreateGameRequest{PlayerId: playerIDs}
	response, err := client.Create(context.Background(), request)
	if err != nil {
		return "", err
	}

	return response.GameId, nil
}

// createCode is a utility to generate match codes
func createCode() string {
	random, _ := rand.Int(rand.Reader, big.NewInt(500000))
	code := 500000 + int(random.Int64())
	return fmt.Sprintf("%06.f", float64(code))
}

// isDuplicate is a utility to check if match codes are duplicated
func isDuplicate(matches map[string]*match, code string) bool {
	_, ok := matches[code]
	return ok
}

// deleteChannel removes the channel from the player and removes the player if there are no more channels
func (service *Service) deleteChannel(m *match, p *player, i int) {
	p.lock.Lock()
	defer p.lock.Unlock()

	delete(p.channels, i)

	if len(p.channels) == 0 {
		service.deletePlayer(m, p)
	}
}

// deletePlayer removes the player from match, and notifies the remaining players if there are any, otherwise it removes the match
func (service *Service) deletePlayer(m *match, p *player) {
	m.lock.Lock()
	defer m.lock.Unlock()

	delete(m.Players, p.ID)

	// update the indices of the remaining players
	i := 0
	for _, p := range m.Players {
		p.Index = i
		i++
	}

	if len(m.Players) > 0 {
		service.notify(m)
	} else {
		service.deleteMatch(m)
	}
}

// deleteMatch removes the match and deletes the game if there are no remaining matches. It also sends the deleted signal to any open notify goroutines
func (service *Service) deleteMatch(m *match) {
	Logger.Printf("DEBUG MatchService delete match")

	close(m.deleted)

	service.lock.Lock()
	defer service.lock.Unlock()

	if matches, ok := service.matches[m.Game]; ok {
		delete(matches, m.Code)
		//clean up games with no matches left
		if len(matches) == 0 {
			Logger.Printf("INFO MatchService deleting game with no matches in progress; game:%v", m.Game)
			delete(service.matches, m.Game)
		}
	}
}

// scavenge cleans up idle matches
func (service *Service) scavenge() {
	for {
		select {
		case <-time.After(scavengerInterval):
			for _, g := range service.matches {
				for _, m := range g {
					if m.lastUpdated.Add(idleWindow).Before(time.Now().UTC()) {
						service.deleteMatch(m)
					}
				}
			}
		}
	}
}
