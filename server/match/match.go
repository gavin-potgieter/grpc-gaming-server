package match

import (
	"context"
	"crypto/rand"
	"fmt"
	"log"
	"math/big"
	"os"
	"sync"
	"time"

	"server/proto"

	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

var (
	// Logger is the default logger
	Logger = log.New(os.Stdout, "", log.LstdFlags)
)

const (
	// recoveryWindow is the time the match waits if a player is disconnected before gracefully cleaning up
	idleWindow        = 5 * time.Minute
	scavengerInterval = 15 * time.Second
)

// match holds the state of an in progress match while players are being matched for a game
type match struct {
	Game        string             // the game being played (game type)
	Version     string             // the version of the game being played - mismatched versions will error
	Code        string             // player friendly code generated by the server for the player to join the game
	PlayerLimit int                // the number of players required for the match to complete
	Players     map[string]*player // the players of the game
	GameID      string             // the game ID once the match is complete
	location    string             // the location of the game service once the match is complete
	lock        sync.Mutex         // the lock to serialize the match from modification
	lastUpdated time.Time          // the last time the match was updated
	deleted     chan bool          // signal for when the match has been deleted for cleanup
}

type player struct {
	ID      string                 // player identifier (generated by client)
	Index   int                    // player index for the client to synchronise the players - this will change if a player leaves
	channel chan *proto.MatchEvent // match events for the player
}

func newMatch(game string, version string, code string) *match {
	return &match{
		Game:        game,
		Version:     version,
		Code:        code,
		Players:     make(map[string]*player),
		lastUpdated: time.Now().UTC(),
		deleted:     make(chan bool),
	}
}

func newPlayer(id string, index int) *player {
	return &player{
		ID:      id,
		Index:   index,
		channel: make(chan *proto.MatchEvent),
	}
}

// Service provides a running service instance. There is only one service
// instance so critical section management is required in the remaining code.
// All completed matches must be removed or there will be a memory leak.
type Service struct {
	proto.UnimplementedMatchServiceServer	   // "the service implementations must embed the corresponding Unimplemented<ServiceName>Server for future compatibility."
	gameServerURL string                       // the URL of the game server
	lock          sync.Mutex                   // the lock to serialize modification of the active matches
	matches       map[string]map[string]*match // the active matches [by code] (for all players in all matches)
}

// NewService creates a new MatchService
func NewService(gameServerURL string) (*Service, error) {
	service := &Service{
		lock:          sync.Mutex{},
		matches:       make(map[string]map[string]*match),
		gameServerURL: gameServerURL,
	}
	go service.scavenge()
	return service, nil
}

// Match enables a client to register for a match and listen for match notifications
func (service *Service) Match(request *proto.MatchRequest, stream proto.MatchService_MatchServer) error {
	Logger.Printf("INFO MatchService matching; request:%+v", request)

	m, p, err := service.match(request)
	if err != nil {
		Logger.Printf("WARN MatchService could not match; match:%+v, err:%v", request, err.Error())
		return err
	}

	for {
		select {
		case event := <-p.channel:
			//skip events that don't match the current player count to prevent the client getting out of date counts
			if int(event.PlayerCount) == len(m.Players) {
				err = stream.Send(event)
				
				if err != nil { // failed to send to client
					service.deletePlayer(m, p)
					Logger.Printf("WARN MatchService event send failed; game:%v code:%v player:%v err:%v", m.Game, m.Code, p.ID, err.Error())
					return status.Errorf(codes.DataLoss, "listener_aborted")
				}

				Logger.Printf("DEBUG MatchService event sent to client; game:%v code:%v player:%v event:%v", m.Game, m.Code, p.ID, event)
			}
			
		case <-stream.Context().Done(): // closed by client
			Logger.Printf("DEBUG MatchService connection disconnected by client; game:%v code:%v player:%v reason:%v", m.Game, m.Code, p.ID, stream.Context().Err().Error())
			service.deletePlayer(m, p)
			return nil
		case <-m.deleted: // closed by server
			Logger.Printf("DEBUG MatchService connection disconnected by server; game:%v code:%v player:%v", m.Game, m.Code, p.ID)
			return nil
		}
	}
}

// match is a function to have a player join or start a match. It adds
// the new player and assigns them an index, and notifies the other players.
func (service *Service) match(request *proto.MatchRequest) (*match, *player, error) {
	m, err := service.find(request.Game, request.Version, request.Code)
	if err != nil {
		return nil, nil, err
	}

	if request.PlayerId == "" {
		return nil, nil, status.Errorf(codes.InvalidArgument, "invalid_playerId")
	}

	m.lock.Lock()
	defer m.lock.Unlock()

	if _, ok := m.Players[request.PlayerId]; ok {
		return nil, nil, status.Errorf(codes.AlreadyExists, "player_already_connected")
	}

	if len(m.Players) >= int(request.PlayerLimit) {
		return nil, nil, status.Errorf(codes.ResourceExhausted, "match_full")
	}

	p := newPlayer(request.PlayerId, len(m.Players))
	m.Players[request.PlayerId] = p

	// always update the match with player limit from latest request
	m.PlayerLimit = int(request.PlayerLimit)

	//the match is complete
	if len(m.Players) == m.PlayerLimit && m.GameID == "" {
		m.GameID, err = service.createGame(m)
		if err != nil {
			return nil, nil, err
		}
		m.location = service.gameServerURL

	}
	m.lastUpdated = time.Now().UTC()

	service.notify(m)
	return m, p, nil
}

// notify notifies all players of match events
// the anonymous goroutine manages the channel for the grpc stream and closes it once the match completes or the player is deleted
func (service *Service) notify(m *match) {
	for _, p := range m.Players {
		e := &proto.MatchEvent{
			Code:        m.Code,
			PlayerCount: int32(len(m.Players)),
			PlayerIndex: int32(p.Index),
			GameId:      m.GameID,
			Location:    m.location,
		}

		go func(p *player) {
			for {
				Logger.Printf("DEBUG MatchService goroutine entered; game:%v code:%v player:%v event:%v", m.Game, m.Code, p.ID, e)
				select {
				case p.channel <- e:
					Logger.Printf("DEBUG MatchService goroutine exited after send; game:%v code:%v player:%v event:%v", m.Game, m.Code, p.ID, e)
					return
				case <-m.deleted:
					Logger.Printf("DEBUG MatchService goroutine cleaned up; game:%v code:%v player:%v  event:%v", m.Game, m.Code, p.ID, e)
					return
				}
			}
		}(p)

	}
}

// find is a utility function to get the match from the game and code and create the match if it doesn't exist
func (service *Service) find(game string, version string, code string) (*match, error) {
	if game == "" {
		return nil, status.Errorf(codes.InvalidArgument, "invalid_game")
	}

	var matches map[string]*match
	var ok bool

	service.lock.Lock()
	defer service.lock.Unlock()

	if matches, ok = service.matches[game]; !ok {
		matches = make(map[string]*match)
		service.matches[game] = matches
	}

	if code != "" {
		var m *match
		if m, ok = matches[code]; !ok {
			return nil, status.Errorf(codes.NotFound, "match_not_found")
		}
		if m.Version != version {
			return nil, status.Errorf(codes.InvalidArgument, "invalid_version")
		}
		return m, nil
	}

	// generates a unique match code (that isn't currently active)
	for code = createCode(); isDuplicate(matches, code); code = createCode() {
		// pass
	}

	m := newMatch(game, version, code)
	service.matches[game][code] = m
	return m, nil
}

// createGame creates a game on the game service and returns the gameId
func (service *Service) createGame(m *match) (string, error) {
	Logger.Printf("INFO MatchService starting game; game:%v code:%v", m.Game, m.Code)

	// call proto
	conn, err := grpc.Dial(service.gameServerURL, grpc.WithInsecure())
	if err != nil {
		return "", err
	}
	defer conn.Close()

	playerIDs := make([]string, 0)
	for playerID := range m.Players {
		playerIDs = append(playerIDs, playerID)
	}
	client := proto.NewGameServiceClient(conn)
	request := &proto.CreateGameRequest{PlayerId: playerIDs}
	response, err := client.Create(context.Background(), request)
	if err != nil {
		return "", err
	}

	return response.GameId, nil
}

// createCode is a utility to generate match codes
func createCode() string {
	random, _ := rand.Int(rand.Reader, big.NewInt(500000))
	code := 500000 + int(random.Int64())
	return fmt.Sprintf("%06.f", float64(code))
}

// isDuplicate is a utility to check if match codes are duplicated
func isDuplicate(matches map[string]*match, code string) bool {
	_, ok := matches[code]
	return ok
}

// deletePlayer removes the player from match, and notifies the remaining players if there are any, otherwise it removes the match
func (service *Service) deletePlayer(m *match, p *player) {
	m.lock.Lock()
	defer m.lock.Unlock()

	delete(m.Players, p.ID)

	// update the indices of the remaining players
	i := 0
	for _, p := range m.Players {
		p.Index = i
		i++
	}

	if len(m.Players) > 0 {
		service.notify(m)
	} else {
		service.deleteMatch(m)
	}
}

// deleteMatch removes the match and deletes the game if there are no remaining matches. It also sends the deleted signal to any open notify goroutines
func (service *Service) deleteMatch(m *match) {
	Logger.Printf("DEBUG MatchService delete match %v", m.Code)

	close(m.deleted)

	service.lock.Lock()
	defer service.lock.Unlock()

	if matches, ok := service.matches[m.Game]; ok {
		delete(matches, m.Code)
		//clean up games with no matches left
		if len(matches) == 0 {
			delete(service.matches, m.Game)
		}
	}
}

// scavenge cleans up idle matches
func (service *Service) scavenge() {
	for {
		select {
		case <-time.After(scavengerInterval):
			for _, g := range service.matches {
				for _, m := range g {
					if m.lastUpdated.Add(idleWindow).Before(time.Now().UTC()) {
						service.deleteMatch(m)
					}
				}
			}
		}
	}
}
