package match

import (
	"context"
	"crypto/rand"
	"fmt"
	"log"
	"math/big"
	"os"
	"sync"
	"time"

	"server/channel"
	"server/proto"

	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

var (
	// Logger is the default logger
	Logger = log.New(os.Stdout, "", log.LstdFlags)
)

const (
	// RecoveryWindow is the time the match waits if a player is disconnected before gracefully cleaning up
	RecoveryWindow = 20 * time.Second
)

// match holds the state of an in progress match while players are being matched for a game
type match struct {
	Game        string             // the game being played (game type)
	Code        string             // player friendly code generated by the server for the player to join the game
	PlayerLimit int                // the number of players required for the game
	Players     map[string]*player // the players of the game
	GameID      string             // the game ID once the match is complete
	lock        sync.Mutex         // the lock to serialize the match from modification
}

// player is a game player
type player struct {
	ID      string           // player identifier (generated by client)
	Index   int              // player index
	channel *channel.Channel // queue of match events for the player
}

// newPlayer creates a new role
func newPlayer(id string, index int) *player {
	return &player{
		ID:      id,
		channel: channel.NewChannel(),
		Index:   index,
	}
}

// Service provides a running service instance. There is only one service
// instance so critical section management is required in the remaining code.
// All completed matches must be removed or there will be a memory leak.
type Service struct {
	gameServerURL string                       // the URL of the game server
	lock          sync.Mutex                   // the lock to serialize modification of the active matches
	matches       map[string]map[string]*match // the active matches [by code] (for all players in all matches)
}

// NewService creates a new MatchService
func NewService(gameServerURL string) (*Service, error) {
	return &Service{
		lock:          sync.Mutex{},
		matches:       make(map[string]map[string]*match, 0),
		gameServerURL: gameServerURL,
	}, nil
}

// createCode is a utility to generate match codes
func createCode() string {
	random, _ := rand.Int(rand.Reader, big.NewInt(500000))
	code := 500000 + int(random.Int64())
	return fmt.Sprintf("%06.f", float64(code))
}

// isDuplicate is a utility to check if match codes are duplicated
func isDuplicate(matches map[string]*match, code string) bool {
	_, ok := matches[code]
	return ok
}

// match is a function to have a player join or start a match. It adds
// the new player and assigns them an index, and notifies the other players. It
// exits gracefully if the player is already in the match.
func (service *Service) match(request *proto.MatchRequest) (*match, *player, error) {
	m, err := service.find(request.Game, request.Code)
	if err != nil {
		return nil, nil, err
	}

	if request.PlayerId == "" {
		return nil, nil, status.Errorf(codes.InvalidArgument, "invalid_playerId")
	}

	if p, ok := m.Players[request.PlayerId]; ok {
		return m, p, nil
	}

	if len(m.Players) >= int(request.PlayerLimit) {
		return nil, nil, status.Errorf(codes.ResourceExhausted, "match_full")
	}

	m.lock.Lock()
	defer m.lock.Unlock()

	// always update the match with player limit from latest request
	m.PlayerLimit = int(request.PlayerLimit)

	p := newPlayer(request.PlayerId, len(m.Players))
	m.Players[request.PlayerId] = p

	service.notify(m, proto.MatchEvent_UPDATED)

	if len(m.Players) == m.PlayerLimit {
		go service.complete(m)
	}

	return m, p, nil
}

// delete is a utility function for cleaning up completed or abandoned matches
func (service *Service) delete(m *match) {
	Logger.Printf("DEBUG MatchService delete match")

	select {
	case <-time.After(RecoveryWindow):
		Logger.Printf("INFO MatchService deleting match after window; game:%v code:%v", m.Game, m.Code)
	}

	service.lock.Lock()
	defer service.lock.Unlock()

	if matches, ok := service.matches[m.Game]; ok {
		delete(matches, m.Code)
		//clean up games with no matches left
		if len(matches) == 0 {
			Logger.Printf("INFO MatchService deleting game after window; game:%v", m.Game)
			delete(service.matches, m.Game)
		}
	}
}

// notify notifies all players of match events
func (service *Service) notify(m *match, t proto.MatchEvent_Type) {
	for _, player := range m.Players {
		e := &proto.MatchEvent{
			Type:        t,
			Code:        m.Code,
			PlayerCount: int32(len(m.Players)),
			PlayerIndex: int32(player.Index),
			GameId:      m.GameID,
		}
		player.channel.Send(e)
	}
}

// leave is a shared function for when a player leaves cleanly or uncleanly
func (service *Service) leave(m *match, p *player) {
	p.channel.Close()

	m.lock.Lock()
	defer m.lock.Unlock()

	delete(m.Players, p.ID)
	if len(m.Players) == 0 {
		go service.delete(m)
	} else {
		service.notify(m, proto.MatchEvent_UPDATED)
	}
}

// handleStreamDisconnected is a goroutine to cleanup after dirty disconnects. It
// also notifies all remaining players of the disconnect. It gives the player a
// recovery window before removing them effectively blocking new players from taking
// their spot in the match (thereby shielding the other players from noisy network issues).
func (service *Service) handleStreamDisconnected(m *match, p *player) {
	select {
	case _, ok := <-p.channel.Recovered:
		if ok {
			Logger.Printf("INFO MatchService player recovered; game:%v code:%v player:%v", m.Game, m.Code, p.ID)
			return
		}
	case <-time.After(RecoveryWindow):
		Logger.Printf("INFO MatchService player timeout; game:%v code:%v player:%v", m.Game, m.Code, p.ID)
	}
	service.leave(m, p)
}

// find is a utility function to get the match from the game and code and create the match if it doesn't exist
func (service *Service) find(game string, code string) (*match, error) {
	if game == "" {
		return nil, status.Errorf(codes.InvalidArgument, "invalid_game")
	}

	var matches map[string]*match
	var ok bool

	service.lock.Lock()
	defer service.lock.Unlock()

	if matches, ok = service.matches[game]; !ok {
		matches = make(map[string]*match, 0)
		service.matches[game] = matches
	}

	if code != "" {
		var m *match
		if m, ok = matches[code]; !ok {
			return nil, status.Errorf(codes.NotFound, "match_not_found")
		}
		return m, nil
	}

	// generates a unique match code (that isn't currently active)
	for code = createCode(); isDuplicate(matches, code); code = createCode() {
		// pass
	}

	m := &match{
		Game:    game,
		Code:    code,
		Players: make(map[string]*player, 0),
	}
	service.matches[game][code] = m
	return m, nil
}

// complete completes the match
func (service *Service) complete(m *match) error {
	Logger.Printf("INFO MatchService starting game; game:%v code:%v", m.Game, m.Code)

	m.lock.Lock()
	defer m.lock.Unlock()

	if m.GameID != "" {
		Logger.Printf("WARN MatchService already completed; game:%v code:%v", m.Game, m.Code)
		return nil
	}

	// call proto
	conn, err := grpc.Dial(service.gameServerURL, grpc.WithInsecure())
	if err != nil {
		return err
	}
	defer conn.Close()

	playerIDs := make([]string, 0)
	for playerID := range m.Players {
		playerIDs = append(playerIDs, playerID)
	}
	client := proto.NewGameServiceClient(conn)
	request := &proto.CreateGameRequest{PlayerId: playerIDs}
	response, err := client.Create(context.Background(), request)
	if err != nil {
		return err
	}

	m.GameID = response.GameId

	if err != nil {
		return err
	}
	service.notify(m, proto.MatchEvent_COMPLETED)

	go service.delete(m)

	return nil
}

// Match allows a client to register for a match and listen for match notifications
// Once the player count is reached, a game is started, the players are notified, and the match is deleted
func (service *Service) Match(request *proto.MatchRequest, stream proto.MatchService_MatchServer) error {
	Logger.Printf("INFO MatchService matching; request:%+v", request)

	m, p, err := service.match(request)
	if err != nil {
		Logger.Printf("WARN MatchService could not match; match:%+v", request)
		return err
	}

	err = p.channel.Listen()
	if err != nil {
		Logger.Printf("WARN MatchService multiple listeners; match:%+v", request)
		return status.Errorf(codes.InvalidArgument, err.Error())
	}

	defer p.channel.Hangup()

	// next section is to indicate recovery has occurred, and replay failed event
	p.channel.Recover()
	select {
	case event, ok := <-p.channel.SkipBack:
		if !ok { // closed by server
			return nil
		}
		e := event.(*proto.MatchEvent)
		Logger.Printf("DEBUG MatchService recovering game:%v code:%v player:%v event:%+v", m.Game, m.Code, p.ID, event)
		err := stream.Context().Err()
		if err == nil {
			err = stream.Send(e)
		}
		Logger.Printf("DEBUG MatchService recovered game:%v code:%v player:%v event:%+v", m.Game, m.Code, p.ID, event)
		if err != nil { // failed to send to client... again
			Logger.Printf("WARN MatchService event retry failed; game:%v code:%v player:%v", m.Game, m.Code, p.ID)
			p.channel.Retry(e)
			go service.handleStreamDisconnected(m, p)
			return status.Errorf(codes.DataLoss, "listener_aborted")
		}
	default:
		break
	}

	// There are three things that could happen in the next code:
	// 1. An event can be dequeued
	// 2. The channel could be closed by the server
	// 3. The channel could be closed by the client
	events := p.channel.Events
	for {
		select {
		case event, ok := <-events:
			if !ok { // closed by server
				return nil
			}
			e := event.(*proto.MatchEvent)
			Logger.Printf("DEBUG MatchService sending game:%v code:%v player:%v event:%+v", m.Game, m.Code, p.ID, event)
			err := stream.Context().Err()
			if err == nil {
				err = stream.Send(e)
			}
			Logger.Printf("DEBUG MatchService sent game:%v code:%v player:%v event:%+v", m.Game, m.Code, p.ID, event)
			if err != nil { // failed to send to client
				Logger.Printf("WARN MatchService event send failed; game:%v code:%v player:%v", m.Game, m.Code, p.ID)
				p.channel.Retry(e)
				go service.handleStreamDisconnected(m, p)
				return status.Errorf(codes.DataLoss, "listener_aborted")
			}
		case <-stream.Context().Done(): // closed by client
			Logger.Printf("WARN MatchService connection disconnected by client; game:%v code:%v player:%v", m.Game, m.Code, p.ID)
			p.channel.Retry(nil)
			go service.handleStreamDisconnected(m, p)
			return nil
		}
	}
}
