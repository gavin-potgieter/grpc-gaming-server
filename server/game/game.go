package game

import (
	"context"
	"log"
	"os"
	"sync"
	"time"

	"server/proto"

	"server/channel"

	"github.com/google/uuid"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

var (
	// Logger is the default logger
	Logger = log.New(os.Stdout, "", log.LstdFlags)
)

const (
	// recoveryWindow is the time the game waits if a player is disconnected before gracefully cleaning up
	recoveryWindow    = 5 * time.Second
	idleWindow        = 30 * time.Minute
	scavengerInterval = 15 * time.Second
	playerCount       = "PLAYER_COUNT"
	idleAbort         = "IDLE_ABORT"
)

// player is a game player
type player struct {
	ID        string           // player identifier (generated by client)
	connected bool             // if the player is conected
	channel   *channel.Channel // the queue of game events for the player
}

// newPlayer creates a new role
func newPlayer(id string) *player {
	return &player{
		ID:      id,
		channel: channel.NewChannel(),
	}
}

// game is a running instance of a game
type game struct {
	ID          string             // the game identifier generated by the server
	Players     map[string]*player // the players of the game
	lock        sync.Mutex         // the lock to serialize the game from modification
	lastUpdated time.Time          // the last time an event happened
}

// Service provides a running game service instance.
// There is only one service instance so critical section management
// is required in the remaining code. All completed games must be
// removed or there will be a memory leak.
type Service struct {
	proto.UnimplementedGameServiceServer  // "the service implementations must embed the corresponding Unimplemented<ServiceName>Server for future compatibility."
	lock sync.Mutex                       // the lock to serialize modification of the active games
	games map[string]*game                // the active games (for all players in all games)
}

// NewService creates a new game service
func NewService() (*Service, error) {
	service := &Service{
		games: make(map[string]*game),
		lock:  sync.Mutex{},
	}

	go service.scavenge()
	return service, nil
}

// scavenge cleans up idle games
func (service *Service) scavenge() {
	for {
		time.Sleep(scavengerInterval)
		for _, g := range service.games {
			if g.lastUpdated.Add(idleWindow).Before(time.Now().UTC()) {
				service.end(g)
			}
		}
	}
}

// playerCountChanged sends a notification to all players of a change in connected players
func (service *Service) playerCountChanged(g *game) {
	var count int
	for _, player := range g.Players {
		if player.connected {
			count++
		}
	}

	service.notify(g, &proto.GameEvent{
		Key:      playerCount,
		Type:     proto.GameEvent_DATA_INT,
		ValueInt: int32(count),
	})
}

// play allows a player to play a game and creates the game and player if they don't exist
func (service *Service) play(gameID string, playerID string) (*game, *player, error) {
	if gameID == "" {
		return nil, nil, status.Errorf(codes.InvalidArgument, "invalid_game_id")
	}
	if playerID == "" {
		return nil, nil, status.Errorf(codes.InvalidArgument, "invalid_player_id")
	}

	service.lock.Lock()
	defer service.lock.Unlock()

	var g *game
	var p *player
	var ok bool
	if g, ok = service.games[gameID]; !ok {
		return nil, nil, status.Errorf(codes.InvalidArgument, "invalid_game_id")
	}

	if p, ok = g.Players[playerID]; !ok {
		return nil, nil, status.Errorf(codes.InvalidArgument, "invalid_player_id")
	}
	if !p.connected {
		p.connected = true
		service.playerCountChanged(g)
	}

	return g, p, nil
}

// notify is a utility function to notify all players of game events.
// It sanitizes uneccessary data from events. It also stores non transient events
// on the game history to enable replaying and therefore resynchronization of players
func (service *Service) notify(g *game, e *proto.GameEvent) {
	e.PlayerId = ""
	e.GameId = ""

	for _, player := range g.Players {
		player.channel.Send(e)
	}
	g.lastUpdated = time.Now().UTC()
}

// end ends the current game by:
// 1. closing all player channels (causes disconnection of player streams)
// 2. removing the game from the active games
// 3. Calling the callback on the game service
func (service *Service) end(g *game) {

	service.notify(g, &proto.GameEvent{
		Key:  idleAbort,
		Type: proto.GameEvent_DATA_NONE,
	})

	select {
	case <-time.After(recoveryWindow):
		Logger.Printf("INFO GameService ending game after window; game:%v", g.ID)
	}

	service.lock.Lock() // ensure only one player ends the game - pessimistic
	defer service.lock.Unlock()

	// checks that the game has not already been ended
	if _, ok := service.games[g.ID]; !ok {
		return
	}

	Logger.Printf("INFO GameService cleaning up game %v", g.ID)

	for _, player := range g.Players {
		player.channel.Close()
	}

	delete(service.games, g.ID)
}

// leave is a shared function for when a player leaves cleanly or uncleanly
func (service *Service) leave(g *game, p *player) {
	p.channel.Close()

	g.lock.Lock()
	defer g.lock.Unlock()

	p.connected = false
	service.playerCountChanged(g)
}

// handleStreamDisconnected is a goroutine to cleanup after dirty disconnects. It
// also notifies all remaining players of the disconnect. It gives the player a
// recovery window before removing them (thereby shielding the other players from noisy network issues).

func (service *Service) handleStreamDisconnected(g *game, p *player) {
	select {
	case _, ok := <-p.channel.Recovered:
		if ok {
			Logger.Printf("INFO GameService player recovered; game:%v player:%v", g.ID, p.ID)
			return
		}
	case <-time.After(recoveryWindow):
		Logger.Printf("INFO GameService player timeout; game:%v player:%v", g.ID, p.ID)
	}
	service.leave(g, p)
}

// streamSend sends events from the current player channel to the player client
func (service *Service) streamSend(stream proto.GameService_PlayServer, g *game, p *player) error {
	err := p.channel.Listen()
	if err != nil {
		Logger.Printf("WARN GameService multiple listeners; game:%v player:%v", g.ID, p.ID)
		return status.Errorf(codes.InvalidArgument, err.Error())
	}
	defer p.channel.Hangup()

	// next section is to indicate recovery has occurred, and replay failed event
	p.channel.Recover()
	select {
	case event, ok := <-p.channel.SkipBack:
		if !ok { // closed by server
			return nil
		}
		gameEvent := event.(*proto.GameEvent)
		Logger.Printf("DEBUG GameService recovering game:%v player:%v event:%+v", g.ID, p.ID, event)
		err := stream.Context().Err()
		if err == nil {
			err = stream.Send(gameEvent)
		}
		Logger.Printf("DEBUG GameService recovered game:%v player:%v event:%+v", g.ID, p.ID, event)
		if err != nil { // failed to send to client... again
			Logger.Printf("WARN GameService event retry failed; game:%v player:%v", g.ID, p.ID)
			p.channel.Retry(gameEvent)
			go service.handleStreamDisconnected(g, p)
			return status.Errorf(codes.DataLoss, "listener_aborted")
		}
	default:
		break
	}

	// There are three things that could happen in the next code:
	// 1. An event can be dequeued
	// 2. The channel could be closed by the server
	// 3. The channel could be closed by the client
	events := p.channel.Events
	for {
		select {
		case event, ok := <-events:
			if !ok { // closed by server
				return nil
			}
			e := event.(*proto.GameEvent)

			Logger.Printf("DEBUG GameService sending game:%v player:%v event:%+v", g.ID, p.ID, event)
			err := stream.Context().Err()
			if err == nil {
				err = stream.Send(e)
			}
			Logger.Printf("DEBUG GameService sent game:%v player:%v event:%+v", g.ID, p.ID, event)

			if err != nil { // failed to send to client
				Logger.Printf("WARN GameService event send failed; game:%v player:%v", g.ID, p.ID)
				p.channel.Retry(e)
				go service.handleStreamDisconnected(g, p)
				return status.Errorf(codes.DataLoss, "listener_aborted")
			}
		case <-stream.Context().Done(): // closed by client
			Logger.Printf("WARN GameService connection disconnected by client; game:%v player:%v", g.ID, p.ID)
			p.channel.Retry(nil)
			go service.handleStreamDisconnected(g, p)
			return nil
		}
	}
}

// streamReceive is a goroutine to receive and dispatch events from the player client
func (service *Service) streamReceive(stream proto.GameService_PlayServer, g *game, p *player) error {
	for {
		event, err := stream.Recv()
		//Logger.Printf("DEBUG GameService received game:%v player:%v event:%+v", game.ID, player.ID, event)
		if err != nil {
			if err.Error() != "rpc error: code = Canceled desc = context canceled" {
				Logger.Printf("INFO GameService play receive failed; game:%v player:%v", g.ID, p.ID)
			}
			return err
		}
		service.notify(g, event)
	}
}

// Create creates a game with its players
func (service *Service) Create(context context.Context, request *proto.CreateGameRequest) (*proto.CreateGameResponse, error) {
	if len(request.PlayerId) == 0 {
		return nil, status.Errorf(codes.InvalidArgument, "invalid_player_id")
	}

	service.lock.Lock()
	defer service.lock.Unlock()

	gID, err := uuid.NewRandom()
	if err != nil {
		return nil, status.Errorf(codes.Internal, "game_creation_failed")
	}
	gameID := gID.String()
	Logger.Printf("INFO GameService creating; game:%v player:%#v", gameID, request.PlayerId)

	g := &game{
		ID:          gameID,
		Players:     make(map[string]*player, 0),
		lastUpdated: time.Now().UTC(),
	}
	for _, playerID := range request.PlayerId {
		g.Players[playerID] = newPlayer(playerID)
	}
	service.games[gameID] = g

	return &proto.CreateGameResponse{GameId: gameID}, nil
}

// Play is for all bi-directional game events between the client and server
func (service *Service) Play(stream proto.GameService_PlayServer) error {
	initialEvent, err := stream.Recv()
	if err != nil {
		return err
	}
	Logger.Printf("INFO GameService playing; game:%v player:%v", initialEvent.GameId, initialEvent.PlayerId)

	g, p, err := service.play(initialEvent.GameId, initialEvent.PlayerId)
	if err != nil {
		return err
	}

	go func() {
		service.streamReceive(stream, g, p)
	}()

	err = service.streamSend(stream, g, p)
	if err != nil {
		return err
	}
	return nil
}
