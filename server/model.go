package main

import (
	"sync"
	"time"

	"github.com/gavin-potgieter/sensense-server/server/proto"
	"github.com/google/uuid"
)

const (
	// PlayerLimit is the total number of players
	PlayerLimit = 3
	// PlayerRecoveryTime is the time the game waits if a player is disconnected before gracefully cleaning up
	PlayerRecoveryTime = 20 * time.Second
	// TimerInterval is the interval that timer events are sent in seconds
	TimerInterval = 3 // 10

	// Blind is the player who can't see
	Blind = 0
	// Deaf is the player who can't hear
	Deaf = 1
	// Mute is the player who can't talk
	Mute = 2

	// SequenceNumberKey is the key for the initialization of the puzzle event stream sent by the client. The value must be an integer of the event sequence to start the stream from
	SequenceNumberKey = "SEQN"
	// InitialConditionsKey is the key for the initial conditions event sent by the server. The value must be a string.
	InitialConditionsKey = "INCO"
	// RoleKey is the key for the role event. The value must be a integer sent by the server.
	RoleKey = "ROLE"
	// ResultKey is the key for the result of the puzzle event sent by the server. The value must be a string based on one of the constants defined below.
	ResultKey = "RSLT"
	// NameKey is the key for the name of the puzzle event sent by the server. The value must be a string.
	NameKey = "NAME"
	// TimeKey is the key for the seconds remaining event sent by the server. The value must be a int.
	TimeKey = "TIME"
	// PlayerMissingKey is the key for when a player is missing (probably due to connection issues) sent by the server. The value must be a int (the role of the missing player).
	PlayerMissingKey = "PMIA"
	// AllAboardKey is the key for when all players are connected to the puzzle. The value must be a int (the time remaining in seconds).
	AllAboardKey = "ABRD"

	// ResultAbort is the cancelled result value
	ResultAbort = "ABORT"
	// ResultLose is the failed result value
	ResultLose = "LOSE"
	// ResultWin is the success result value
	ResultWin = "WIN"
)

// Role is a sensense player role for a puzzle
type Role int

// Player is a game player
type Player struct {
	ID                string                  // player identifier (generated by client)
	Role              Role                    // player current role
	GameChannel       *Channel                // queue of game events for the player
	PuzzleChannel     chan *proto.PuzzleEvent // the queue of puzzle events for the player
	PuzzleChannelLock sync.RWMutex            // the lock to serialize the allocation of the puzzle event queue
}

// NewPlayer creates a new role
func NewPlayer(id string, role Role) *Player {
	return &Player{
		ID:                id,
		GameChannel:       NewChannel(),
		PuzzleChannelLock: sync.RWMutex{},
		Role:              role,
	}
}

// Game is a running instance of a SenSense game
type Game struct {
	Code     int                // player friendly code generated by the server for the player to join the game
	PuzzleID *uuid.UUID         // the active puzzle identifier (used to ensure that only one puzzle is active)
	ID       uuid.UUID          // the game identifier generated by the server
	Lock     sync.Mutex         // the lock to serialize the game from modification
	Players  map[string]*Player // the players of the game
}

// EndPuzzleCallback is raised when a puzzle ends
type EndPuzzleCallback func()

// Puzzle is a running instance of a SenSense game level
type Puzzle struct {
	EndPuzzleCallback EndPuzzleCallback    // a callback that is raised when the game ends (used to deactivate the game puzzle)
	ID                uuid.UUID            // the puzzle identifier generated by the server
	InitialConditions string               // an unstructured initial puzzle state TODO: could be merged into a standard puzzle event (although questions remain as to which user is then responsible)
	Name              string               // the name of the puzzle so players know what puzzle they're playing
	Lock              sync.Mutex           // the lock to serialize the puzzle from modification
	Players           map[string]*Player   // the players of the puzzle
	ticker            *time.Ticker         // the game timer / ticker
	timeRemaining     int                  // the time remaining for the puzzle (counts down automatically)
	history           []*proto.PuzzleEvent // the durable event history
	historyLock       sync.Mutex           // the history lock serializes history modifications
}

// Paused determines if the puzzle is paused due to an MIA player
func (puzzle *Puzzle) Paused() bool {
	connectedPlayers := 0
	for _, player := range puzzle.Players {
		player.PuzzleChannelLock.RLock()
		if player.PuzzleChannel != nil {
			connectedPlayers++
		}
		player.PuzzleChannelLock.RUnlock()
	}
	return connectedPlayers != PlayerLimit
}
